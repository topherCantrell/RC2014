#### Labels
#0x8000          = 0x0000
fn_execute       = 0x007F
fn_ping          = 0x0022
fn_read          = 0x0043
fn_read_port     = 0x002B
fn_write         = 0x0061
fn_write_port    = 0x0037
getChar          = 0x009D
getChar_wait     = 0x009D
initSerial       = 0x008E
initWait1        = 0x0094
initWait2        = 0x009A
main_loop        = 0x0006
ping_string      = 0x0088
read_loop        = 0x0053
sendChar         = 0x00A6
sendChar_wait    = 0x00A7
sendStr          = 0x00B2
sendStr_out      = 0x00BF
write_loop       = 0x0071

#### Defines
SER_CR           = 0x0080
SER_CR_7E1       = 0x0008
SER_CR_7E2       = 0x0000
SER_CR_7O1       = 0x000C
SER_CR_7O2       = 0x0004
SER_CR_8E1       = 0x0018
SER_CR_8N1       = 0x0014
SER_CR_8N2       = 0x0010
SER_CR_8O2       = 0x001C
SER_CR_BY_1      = 0x0000
SER_CR_BY_16     = 0x0001
SER_CR_BY_64     = 0x0002
SER_CR_RESET     = 0x0003
SER_CR_RTShigh_TXIoff = 0x0002
SER_CR_RTSlow_TXIoff = 0x0000
SER_CR_RTSlow_TXIoff_BRK = 0x0003
SER_CR_RTSlow_TXIon = 0x0001
SER_CR_RXI_Enable = 0x0080
SER_RX           = 0x0081
SER_SR           = 0x0080
SER_SR_CTS       = 0x0008
SER_SR_DCD       = 0x0004
SER_SR_FE        = 0x0010
SER_SR_IRQ       = 0x0080
SER_SR_OVRN      = 0x0020
SER_SR_PE        = 0x0040
SER_SR_RDFR      = 0x0001
SER_SR_TDRE      = 0x0002
SER_TX           = 0x0081
_CPU             = Z80

                  ; -------------------------------------------------------------
                  ; Two-byte values in MSB-first
                  ;
                  ; 1aaLL    - Read LL bytes beginning at aa
                  ; 2aaLL... - Write LL byte beginning at aa
                  ; 3p       - Read the port p
                  ; 4pV      - Write the value V to port p
                  ; 5aa      - Execute address aa
                  ;
                  ; Anything else: responds with "Here2" (2=version)
                  ; -------------------------------------------------------------
                  
                  ._CPU = Z80
                  
                  ; http://www.vcfed.org/forum/archive/index.php/t-52356.html
                  
                  ; The master reset (CR0, CR1) must be set immediately after powerup.
                  ; CR5 and CR6 should be programmed to define the state of RTS when later master resets are given
                  
                  ;  CS0 -> M1
                  ;  CS1 -> A7
                  ; -CS2 -> A6
                  ;  RS  -> A0
                  
                  ; 10xxxxxx
                  
                  .SER_CR = 0x80 ; Write
                  ; 7 - CR7 Receive Interrupt Enable
                  ; 6 - CR6   +-- Transmitter Control Bits
                  ; 5 - CR5   +   00=RTSlow_TXIoff, 01=RTSlow_TXIon, 10=RTShigh_TXIoff, 11=RTSlow_TXIoff_BRK
                  ; 4 - CR4     +
                  ; 3 - CR3     +-- Word select : 000=7E2, 001=7O2, 010=7E1, 011=7O1
                  ; 2 - CR2     +                 100=8N2, 101=8N1, 110=8E1, 111=8O1
                  ; 1 - CR1       +-- Counter divide
                  ; 0 - CR0       +   00=By1, 01=By16, 10=By64, 11=MasterReset
                  .SER_CR_BY_1  = 0b0_00_000_00
                  .SER_CR_BY_16 = 0b0_00_000_01
                  .SER_CR_BY_64 = 0b0_00_000_10 ; Use this for RC2014 board
                  .SER_CR_RESET = 0b0_00_000_11
                  ;
                  .SER_CR_7E2 = 0b0_00_000_00
                  .SER_CR_7O2 = 0b0_00_001_00
                  .SER_CR_7E1 = 0b0_00_010_00
                  .SER_CR_7O1 = 0b0_00_011_00
                  .SER_CR_8N2 = 0b0_00_100_00
                  .SER_CR_8N1 = 0b0_00_101_00
                  .SER_CR_8E1 = 0b0_00_110_00
                  .SER_CR_8O2 = 0b0_00_111_00
                  ;
                  .SER_CR_RTSlow_TXIoff     = 0b0_00_000_00
                  .SER_CR_RTSlow_TXIon      = 0b0_00_000_01
                  .SER_CR_RTShigh_TXIoff    = 0b0_00_000_10
                  .SER_CR_RTSlow_TXIoff_BRK = 0b0_00_000_11
                  ;
                  .SER_CR_RXI_Enable = 0b1_00_000_00
                  
                  .SER_SR = 0x80 ; Read
                  ;  7 - IRQ  State of IRQ output (1 if interrupt is triggered). Clear by reading RX or writing TX.
                  ;  6 - PE   Parity Error flag
                  ;  5 - OVRN Receiver Overrun error flag
                  ;  4 - FE   Framing Error
                  ;  3 - CTS  Clear to Send
                  ;  2 - DCD  Data Carrier Detect
                  ;  1 - TDRE Transmit Data Register Empty
                  ;  0 - RDFR Receive Data Register Full
                  .SER_SR_RDFR = 0b00000001
                  .SER_SR_TDRE = 0b00000010
                  .SER_SR_DCD  = 0b00000100
                  .SER_SR_CTS  = 0b00001000
                  .SER_SR_FE   = 0b00010000
                  .SER_SR_OVRN = 0b00100000
                  .SER_SR_PE   = 0b01000000
                  .SER_SR_IRQ  = 0b10000000
                  
                  ; TX/RX data
                  
                  .SER_TX = 0x81 ; Write
                  .SER_RX = 0x81 ; Read
                  
                  0x0000: ; ROM
                  #0x8000:  ; RAM
                  
0000: 31 00 00         LD    SP,0         ; First on stack at FFFE,FFFF
0003: CD 8E 00         CALL  initSerial
                  
                  main_loop:
                  
0006: CD 9D 00         CALL  getChar
                  
0009: FE 01            CP    1
000B: CA 43 00         JP    Z,fn_read
                  
000E: FE 02            CP    2
0010: CA 61 00         JP    Z,fn_write
                  
0013: FE 03            CP    3
0015: CA 2B 00         JP    Z,fn_read_port
                  
0018: FE 04            CP    4
001A: CA 37 00         JP    Z,fn_write_port
                  
001D: FE 05            CP    5
001F: CA 7F 00         JP    Z,fn_execute
                  
                  fn_ping:
0022: 21 88 00         LD    HL,ping_string
0025: CD B2 00         CALL  sendStr
0028: C3 06 00         JP    main_loop
                  
                  fn_read_port:
002B: CD 9D 00         CALL      getChar       ; Port
002E: 4F               LD        C,A
002F: ED 78            IN        A,(C)
0031: CD A6 00         CALL      sendChar
0034: C3 06 00         JP        main_loop
                  
                  fn_write_port:
0037: CD 9D 00         CALL      getChar       ; Port
003A: 4F               LD        C,A
003B: CD 9D 00         CALL      getChar
003E: ED 79            OUT       (C),A
0040: C3 06 00         JP        main_loop
                  
                  fn_read:
0043: CD 9D 00         CALL      getChar       ; Destination
0046: 67               LD        H,A
0047: CD 9D 00         CALL      getChar
004A: 6F               LD        L,A
004B: CD 9D 00         CALL      getChar       ; Length
004E: 57               LD        D,A
004F: CD 9D 00         CALL      getChar
0052: 5F               LD        E,A
                  read_loop:
0053: 7E               LD        A,(HL)        ; Read from memory
0054: CD A6 00         CALL      sendChar      ; Write to serial
0057: 23               INC       HL            ; Bump the destination pointer
0058: 1B               DEC       DE            ; Decrement the length
0059: 7A               LD        A,D           ; All ...
005A: B3               OR        E             ; ... done?
005B: C2 53 00         JP        NZ,read_loop  ; No ... still more to do
005E: C3 06 00         JP        main_loop
                  
                  fn_write:
0061: CD 9D 00         CALL      getChar       ; Destination
0064: 67               LD        H,A
0065: CD 9D 00         CALL      getChar
0068: 6F               LD        L,A
0069: CD 9D 00         CALL      getChar       ; Length
006C: 57               LD        D,A
006D: CD 9D 00         CALL      getChar
0070: 5F               LD        E,A
                  write_loop:
0071: CD 9D 00         CALL      getChar       ; Get byte
0074: 77               LD        (HL),A        ; Store it to RAM
0075: 23               INC       HL            ; Bump the destination pointer
0076: 1B               DEC       DE            ; Decrement the length
0077: 7A               LD        A,D           ; All ...
0078: B3               OR        E             ; ... loaded?
0079: C2 71 00         JP        NZ,write_loop ; No ... still more to do
007C: C3 06 00         JP        main_loop
                  
                  fn_execute:
007F: CD 9D 00         CALL      getChar       ; Destination
0082: 67               LD        H,A
0083: CD 9D 00         CALL      getChar
0086: 6F               LD        L,A
0087: E9               JP        (HL)          ; Jump to the destination
                  
                  ping_string:
0088: 48 65 72 65 32 00 . 0x48,0x65,0x72,0x65,50,0
                  
                  ; Needs serial.asm
                  
                  initSerial:
008E: 3E 03            LD        A,SER_CR_RESET               ; Master reset ...
0090: D3 80            OUT       (SER_CR),A                   ; ... the 6850
0092: 06 00            LD        B,0                          ; (Delay may not be needed)
                  initWait1:
0094: 10 FE            DJNZ      initWait1                    ; Short delay (may not be needed)
0096: 3E 16            LD        A,SER_CR_BY_64 | SER_CR_8N1  ; 8N1 at 115200
0098: D3 80            OUT       (SER_CR),A                   ; Set the serial protocol
                  initWait2:
009A: 10 FE            DJNZ      initWait2                    ; Short delay (may not be needed)
009C: C9               RET
                  
                  getChar:
                  ; Wait for a character from the input.
                  ; Return it in A
                  getChar_wait:
009D: DB 80            IN        A,(SER_CR)      ; Data ready ...
009F: E6 01            AND       SER_SR_RDFR     ; ... to be read?
00A1: 28 FA            JR        Z,getChar_wait  ; 0=No ... wait for data
00A3: DB 81            IN        A,(SER_RX)      ; Read the data
00A5: C9               RET
                  
                  sendChar:
                  ; Wait for buffer to clear.
                  ; Send character in A
00A6: 47               LD        B,A             ; We need A for I/O
                  sendChar_wait:
00A7: DB 80            IN        A,(SER_CR)      ; Buffer is ready ...
00A9: E6 02            AND       SER_SR_TDRE     ; ... for new data?
00AB: CA A7 00         JP        Z,sendChar_wait ; 0=No ... wait for ready
00AE: 78               LD        A,B             ; Back to A for I/O
00AF: D3 81            OUT       (SER_TX),A      ; Write the data
00B1: C9               RET
                  
                  sendStr:
                  ; Send a string of characters pointed to by HL
                  ; (null terminated)
00B2: 7E               LD        A,(HL)          ; Next character
00B3: FE 00            CP        0
00B5: CA BF 00         JP        Z,sendStr_out   ; 0 means We are done
00B8: 23               INC       HL              ; Bump pointer
00B9: CD A6 00         CALL      sendChar        ; Write the character
00BC: C3 B2 00         JP        sendStr         ; Keep printing
                  sendStr_out:
00BF: C9               RET
